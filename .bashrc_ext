# Personalized bash settings for Daniil Bargman, daniil.bargman@gmail.com #####
# ADD THIS TO THE END OF THE .bashrc FILE: source .myBashSettings

#################### powerline settings #######################################
#powerline-daemon -q
#POWERLINE_BASH_CONTINUATION=1
#POWERLINE_BASH_SELECT=1
#. /usr/local/lib/python3.4/dist-packages/powerline/bindings/bash/powerline.sh

#################### basic terminal settings ##################################

# SET 256-COLOR SUPPORT IN TERMINAL
export TERM='xterm-256color'

# Set custom prompt
function get_virtualenv {
    envname=$(basename "$CONDA_PREFIX")
    [ "$envname" = "" ] && echo "base" || echo "$envname"
}
function get_k8s_context {
    # [ "$KUBECONFIG" = "" ] && echo "" \
    #   || echo " | k8s-context:$(kubectl config current-context)"
    k8s_context=$(kubectl config current-context 2> /dev/null)
    [ "$k8s_context" = "" ] && echo "no-k8s" || echo "$k8s_context"
}
FG=("\[\033[38;5;74m\]" "\[\033[38;5;79m\]" "\[\033[38;5;136m\]" "\[\033[38;5;142m\]" "\[\033[38;5;220m\]" "\[\033[38;5;250m\]")
BG=("\[\033[48;5;236m\]" "\[\033[48;5;237m\]" "\[\033[48;5;238m\]" "\[\033[48;5;239m\]" "\[\033[48;5;240m\]")
BOLD="\[$(tput bold)\]"
RESET="\[$(tput sgr0)\]"

export PS1="\n${FG[-1]}(${FG[2]}\$(get_virtualenv)${FG[-1]}) ${FG[1]}\$(get_k8s_context)${FG[-1]} : ${FG[3]}\w\n${BG[2]}${FG[4]}[\t] ${BOLD}${FG[0]}\u ${FG[-1]}=> \\$""${RESET} "

# Make bash behave more like vim
set -o vi

#################### project management settings ##############################

# project launcher directory
executables=~/executables

# Add dropbox project folder to environment
PATH=${PATH//:$executables/}":$executables"

# Make all files in $executables directory executable
for filename in $(echo $executables/*)
do
    chmod u+x $filename
done

# When launching project with vim, disable passthrough of ctrl-s
vim()
{
    local STTYOPTS="$(stty --save)"
    stty stop '' -ixoff
    command vim "$@"
    stty "$STTYOPTS"
}

# export to terminal
export -f vim

# open vim with a session file if one exists
alias vimsession='[[ -e .LastVimSession.vim ]] && vim -S .LastVimSession.vim || vim'

# shortcut to start secure connection
alias lock='sudo ufw enable && sudo -b openvpn --config ~/vpn/dbargman-server2.ovpn --auth-nocache'
alias unlock='sudo ufw disable && sudo killall openvpn '

# use -la flag by default with the ls command
alias la="ls -lahF --color=always"

# alias update commands
alias update="sudo apt-get update && sudo apt-get upgrade; sudo apt-get clean && sudo apt-get autoremove"

# alias nmcli d wifi with "wifi"
alias wifi="nmcli d wifi"

# Automatically add completion for all aliases to commands having completion functions
function alias_completion {
    local namespace="alias_completion"

    # parse function based completion definitions, where capture group 2 => function and 3 => trigger
    local compl_regex='complete( +[^ ]+)* -F ([^ ]+) ("[^"]+"|[^ ]+)'
    # parse alias definitions, where capture group 1 => trigger, 2 => command, 3 => command arguments
    local alias_regex="alias ([^=]+)='(\"[^\"]+\"|[^ ]+)(( +[^ ]+)*)'"

    # create array of function completion triggers, keeping multi-word triggers together
    eval "local completions=($(complete -p | sed -Ene "/$compl_regex/s//'\3'/p"))"
    (( ${#completions[@]} == 0 )) && return 0

    # create temporary file for wrapper functions and completions
    rm -f "/tmp/${namespace}-*.tmp" # preliminary cleanup
    local tmp_file; tmp_file="$(mktemp "/tmp/${namespace}-${RANDOM}XXX.tmp")" || return 1

    local completion_loader; completion_loader="$(complete -p -D 2>/dev/null | sed -Ene 's/.* -F ([^ ]*).*/\1/p')"

    # read in "<alias> '<aliased command>' '<command args>'" lines from defined aliases
    local line; while read line; do
        eval "local alias_tokens; alias_tokens=($line)" 2>/dev/null || continue # some alias arg patterns cause an eval parse error
        local alias_name="${alias_tokens[0]}" alias_cmd="${alias_tokens[1]}" alias_args="${alias_tokens[2]# }"

        # skip aliases to pipes, boolean control structures and other command lists
        # (leveraging that eval errs out if $alias_args contains unquoted shell metacharacters)
        eval "local alias_arg_words; alias_arg_words=($alias_args)" 2>/dev/null || continue
        # avoid expanding wildcards
        read -a alias_arg_words <<< "$alias_args"

        # skip alias if there is no completion function triggered by the aliased command
        if [[ ! " ${completions[*]} " =~ " $alias_cmd " ]]; then
            if [[ -n "$completion_loader" ]]; then
                # force loading of completions for the aliased command
                eval "$completion_loader $alias_cmd"
                # 124 means completion loader was successful
                [[ $? -eq 124 ]] || continue
                completions+=($alias_cmd)
            else
                continue
            fi
        fi
        local new_completion="$(complete -p "$alias_cmd")"

        # create a wrapper inserting the alias arguments if any
        if [[ -n $alias_args ]]; then
            local compl_func="${new_completion/#* -F /}"; compl_func="${compl_func%% *}"
            # avoid recursive call loops by ignoring our own functions
            if [[ "${compl_func#_$namespace::}" == $compl_func ]]; then
                local compl_wrapper="_${namespace}::${alias_name}"
                    echo "function $compl_wrapper {
                        (( COMP_CWORD += ${#alias_arg_words[@]} ))
                        COMP_WORDS=($alias_cmd $alias_args \${COMP_WORDS[@]:1})
                        (( COMP_POINT -= \${#COMP_LINE} ))
                        COMP_LINE=\${COMP_LINE/$alias_name/$alias_cmd $alias_args}
                        (( COMP_POINT += \${#COMP_LINE} ))
                        $compl_func
                    }" >> "$tmp_file"
                    new_completion="${new_completion/ -F $compl_func / -F $compl_wrapper }"
            fi
        fi

        # replace completion trigger by alias
        new_completion="${new_completion% *} $alias_name"
        echo "$new_completion" >> "$tmp_file"
    done < <(alias -p | sed -Ene "s/$alias_regex/\1 '\2' '\3'/p")
    source "$tmp_file" && rm -f "$tmp_file"
}; alias_completion

# for k8s, enable autocompletion
# see https://kubernetes.io/docs/reference/kubectl/cheatsheet/#bash
source <(kubectl completion bash)
alias k=kubectl
complete -F __start_kubectl k

###############################################################################
