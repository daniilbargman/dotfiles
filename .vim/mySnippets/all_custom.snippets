snippet dockerfile "Canvas for an empty dockerfile"

#
# Dockerfile for ${1: Container description}
#
# Author: Daniil Bargman (daniil.bargman@gmail.com)

FROM $0
endsnippet

snippet dbash "Template for well-organized bash scripts"
#!/usr/bin/env bash
# vim: set filetype=sh
#
# ${1: Describe what this script is meant to do}
#
# Author: Daniil Bargman (daniil.bargman@gmail.com)
#
# base directory of this file accounting for symlinks
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until file is no longer a symlink
  BASE_DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
done
BASE_DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
SCRIPT_NAME="${0##*/}"
###############################################################################

# error-safe script settings
set -Eeuo pipefail

# default message appendix on errors
function append_error {
    echo "run '$BASE_DIR/$SCRIPT_NAME -h' for help on '$SCRIPT_NAME'."
    exit 1
}

# trap errors from third-party functions
trap append_error ERR

# manual error handler: refer to help flag, and exit (use in place of echo)
function error_exit {
    echo
    echo \$1
    append_error
}

# help function
function print_help {
cat << EOF

===============================================================================
===============================================================================
===============================================================================

${2: Short description of this script or command}


Usage:

  ${3: Use cases}


Print this help text:

  $SCRIPT_NAME ( --help | -h )


===============================================================================
===============================================================================
===============================================================================
EOF
exit 0
}

# define argument defaults
allowed_args=( ${4: Allowed arguments, including <ARG> for ARG=<VALUE> types} )
help_flags=( "-h" "--help" )

# parse and validate arguments
for i in "${@:1}"; do

    # parse argument into name and value, if it has the form "NAME=VALUE"
    IFS='=' read -r argn argv <<< "$i"

    # print help if requested
    if [[ " ${help_flags[@]} " =~ "$i" ]]; then
        print_help
        exit 0

    # catch illegal arguments and throw error
    elif [[ ! " ${allowed_args[@]} " =~ "$argn" ]]; then
        error_exit "Illegal argument or flag: $argn."

    # apply actual logic to parsed argument
    else
        error_exit "Logic for this argument is not implemented yet."
    fi
done

# actual code ...
$0

# done.
endsnippet
